#!/usr/bin/env python
"""
Script to clear report files generated by App Reviews AI.

This script helps clean up report files by:
1. Removing old timestamped report directories while keeping the most recent ones
2. Clearing visualization files in the reports/visualizations directory
3. Supporting both the main reports directory and the notebooks/reports directory
4. Optionally backing up reports before removing them

Examples:
    # Clear reports keeping the 5 most recent ones
    python clear_reports.py
    
    # Clear all reports (force removal of everything)
    python clear_reports.py --force
    
    # Keep only the 3 most recent reports
    python clear_reports.py --keep 3
    
    # Create a backup before clearing
    python clear_reports.py --backup
    
    # Show detailed information during execution
    python clear_reports.py --verbose
"""
import os
import shutil
import argparse
import logging
from datetime import datetime
from pathlib import Path
import sys

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger("app_reviews")

def list_dirs_with_timestamp(path):
    """
    List directories that have timestamp format names (YYYYMMDD_HHMMSS).
    
    Args:
        path: Directory path to search for timestamp-formatted directories
        
    Returns:
        List of dictionaries containing directory info, sorted by timestamp (newest first)
    """
    if not os.path.exists(path):
        return []
    
    timestamp_dirs = []
    timestamp_format = "%Y%m%d_%H%M%S"
    
    try:
        for item in os.listdir(path):
            item_path = os.path.join(path, item)
            if os.path.isdir(item_path):
                # Check if the directory name matches a timestamp format
                try:
                    # Attempt to parse the directory name as a timestamp
                    timestamp = datetime.strptime(item, timestamp_format)
                    timestamp_dirs.append({
                        'path': item_path,
                        'name': item,
                        'timestamp': timestamp
                    })
                except ValueError:
                    # Not a timestamp-formatted directory, skip it
                    pass
    except Exception as e:
        logger.error(f"Error listing directories in {path}: {e}")
        return []
    
    # Sort directories by timestamp (newest first)
    return sorted(timestamp_dirs, key=lambda x: x['timestamp'], reverse=True)

def clear_reports(backup: bool = False, keep_recent: int = 5, verbose: bool = False) -> bool:
    """
    Clear report files from the reports directories, keeping the most recent ones.
    
    Args:
        backup: Whether to create a backup of reports before clearing
        keep_recent: Number of most recent report directories to keep
        verbose: Whether to output detailed information
        
    Returns:
        True if successful, False otherwise
    """
    success = True
    
    # Get project root (the directory where this script is located)
    project_root = os.path.dirname(os.path.abspath(__file__))
    
    # Define paths to clear
    reports_paths = [
        os.path.join(project_root, "reports"),
        os.path.join(project_root, "notebooks", "reports")
    ]
    
    for reports_dir in reports_paths:
        if not os.path.exists(reports_dir):
            logger.warning(f"Reports directory '{reports_dir}' not found. Skipping.")
            continue
        
        logger.info(f"Processing directory: {reports_dir}")
        
        try:
            # Create backup if requested
            if backup:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                backup_dir = f"{reports_dir}_backup_{timestamp}"
                logger.info(f"Creating backup in '{backup_dir}'...")
                shutil.copytree(reports_dir, backup_dir)
                logger.info(f"Backup created successfully.")
            
            # Handle timestamp-formatted directories (like the ones created by the notebook)
            timestamp_dirs = list_dirs_with_timestamp(reports_dir)
            
            if timestamp_dirs:
                # Keep the N most recent directories
                to_keep = timestamp_dirs[:keep_recent]
                to_remove = timestamp_dirs[keep_recent:]
                
                # Log kept directories
                if verbose:
                    for dir_info in to_keep:
                        logger.info(f"Keeping directory: {dir_info['path']} (from {dir_info['timestamp']})")
                
                # Remove old directories
                for dir_info in to_remove:
                    path = dir_info['path']
                    if os.path.exists(path):
                        if verbose:
                            logger.info(f"Removing directory: {path}")
                        try:
                            shutil.rmtree(path)
                        except Exception as e:
                            logger.error(f"Error removing {path}: {e}")
                            success = False
            else:
                if verbose:
                    logger.info(f"No timestamp directories found in {reports_dir}")
            
            # Handle the visualizations directory
            viz_dir = os.path.join(reports_dir, "visualizations")
            
            # Clear or create the visualizations directory
            if os.path.exists(viz_dir):
                logger.info(f"Clearing visualization files from '{viz_dir}'...")
                # Clear all files in the directory
                for file_name in os.listdir(viz_dir):
                    file_path = os.path.join(viz_dir, file_name)
                    if os.path.isfile(file_path) and not file_name.startswith('.git'):
                        if verbose:
                            logger.info(f"Removing file: {file_path}")
                        try:
                            os.remove(file_path)
                        except Exception as e:
                            logger.error(f"Error removing {file_path}: {e}")
                            success = False
            elif reports_dir == os.path.join(project_root, "reports"):
                # Create the directory if it doesn't exist (only for main reports)
                if verbose:
                    logger.info(f"Creating directory: {viz_dir}")
                os.makedirs(viz_dir, exist_ok=True)
            
            # For main reports dir, ensure we have a .gitkeep file
            if reports_dir == os.path.join(project_root, "reports"):
                # Add a .gitkeep file to ensure the directory stays in git
                gitkeep_path = os.path.join(viz_dir, ".gitkeep")
                if not os.path.exists(gitkeep_path):
                    if verbose:
                        logger.info(f"Creating .gitkeep file: {gitkeep_path}")
                    with open(gitkeep_path, 'w') as f:
                        f.write("# This file exists to keep the directory in git\n")
        
        except Exception as e:
            logger.error(f"Error processing directory '{reports_dir}': {e}")
            success = False
    
    if success:
        logger.info("Reports cleanup completed successfully.")
    else:
        logger.warning("Reports cleanup completed with some errors.")
    
    return success

def main():
    """Main entry point for the script."""
    parser = argparse.ArgumentParser(
        description="Clear report files generated by App Reviews AI.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python clear_reports.py                    # Keep 5 most recent reports
  python clear_reports.py --force            # Remove all reports
  python clear_reports.py --keep 3           # Keep only 3 most recent reports
  python clear_reports.py --backup           # Backup before clearing
  python clear_reports.py --verbose          # Show detailed information
        """
    )
    parser.add_argument(
        "--backup", 
        action="store_true", 
        help="Create a backup of reports before clearing"
    )
    parser.add_argument(
        "--keep", 
        type=int, 
        default=5,
        help="Number of most recent report directories to keep (default: 5)"
    )
    parser.add_argument(
        "--force", 
        action="store_true", 
        help="Force removal of all directories, including the ones to keep"
    )
    parser.add_argument(
        "--verbose", 
        action="store_true", 
        help="Show detailed debug information"
    )
    
    args = parser.parse_args()
    
    # Validate args
    if args.keep < 0:
        print(f"Error: --keep value must be non-negative, got {args.keep}")
        return 1
    
    # Set logging level
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # If force is specified, set keep_recent to 0
    keep_recent = 0 if args.force else args.keep
    
    if args.force:
        confirmation = input("Are you sure you want to remove ALL report directories? (y/N): ")
        if confirmation.lower() not in ["y", "yes"]:
            print("Aborted.")
            return 0
    
    try:
        # Clear reports
        success = clear_reports(backup=args.backup, keep_recent=keep_recent, verbose=args.verbose)
        
        if success:
            print("Reports cleared successfully.")
            if args.force:
                print("All report directories were removed.")
            else:
                print(f"The {keep_recent} most recent report directories were kept.")
        else:
            print("Reports cleared with some errors. See log for details.")
            return 1
    except KeyboardInterrupt:
        print("\nOperation was interrupted by the user.")
        return 1
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        logger.exception("Unexpected error")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())